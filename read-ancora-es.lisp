(in-package :nlp)

(def-pos-map :ancora
    (("fa" ".")
     ("fc" ".")
     ("fd" ".")
     ("fe" ".")
     ("fg" ".")
     ("fh" ".")
     ("fi" ".")
     ("fp" ".")
     ("fs" ".")
     ("fx" ".")
     ("fz" ".")
     ("number" "NUM")
     ("zm" "NUM")
     ("zp" "NUM")
     ("ao" "ADJ")
     ("aq" "ADJ")
     ("cc" "CONJ")
     ("cs" "CONJ")
     ("da" "DET")
     ("dd" "DET")
     ("de" "DET")
     ("di" "DET")
     ("dn" "DET")
     ("dp" "DET")
     ("dt" "DET")
     ("nc" "NOUN")
     ("np" "NOUN")
     ("p0" "PRON")
     ("pd" "PRON")
     ("pe" "PRON")
     ("pi" "PRON")
     ("pn" "PRON")
     ("pp" "PRON")
     ("pr" "PRON")
     ("pt" "PRON")
     ("px" "PRON")
     ("rg" "ADV")
     ("rn" "ADV")
     ("sn" "ADP")
     ("sp" "ADP")
     ("va" "VERB")
     ("vm" "VERB")
     ("vs" "VERB")
     ("w" "NOUN")
     ("z" "NUM")
     ("x" "X")
     ("y" "X")
     ("i" "X")))

(defmethod lookup-generic-pos ((name (eql :ancora)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (cdr (assoc pos alist
                  :test (lambda (key1 key2)
                          (let ((regex (format nil "^~A" key2)))
                            (scan regex key1))))))))

(defmethod lookup-specific-pos ((name (eql :ancora)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (let ((tag
             (car (assoc pos alist
                         :test (lambda (key1 key2)
                                 (let ((regex (format nil "^~A" key2)))
                                   (scan regex key1)))))))
        (when tag
          (intern (string-upcase tag) :keyword))))))

(defun parse-ancora-tree (tree)
  (let ((sentences nil) (current-sentence nil))
    (labels
        ((dfs-helper (this-node)
           (cond
             ((and (consp this-node)
                   (eql :@ (first this-node))
                   (every 'consp (rest this-node))
                   (member :|wd| (rest this-node) :key 'first)
                   (or (member :|pos| (rest this-node) :key 'first)
                       (let ((ne (find :|ne| (rest this-node) :key 'first)))
                         (and ne
                              (or (equalp (second ne) "date")
                                  (equalp (second ne) "number"))))))
              (let ((pos
                     (or (lookup-specific-pos
                          :ancora
                          (second (find :|pos| (rest this-node) :key 'first)))
                         (let ((ne (find :|ne| (rest this-node) :key 'first))
                               (wd (find :|wd| (rest this-node) :key 'first)))
                           (when (and ne wd)
                             (cond ((equalp (second ne) "date")
                                    :W)
                                   ((equalp (second ne) "number")
                                    :Z)))))))
                (unless pos
                  (error "Could not determine POS: ~S" this-node))
                (push (cons pos
                            (second (find :|wd| (rest this-node) :key 'first)))
                      current-sentence)))
             ((and (consp this-node)
                   (eql :|sentence| (first this-node)))
              (when current-sentence
                (push (nreverse current-sentence) sentences)
                (setq current-sentence nil))
              (map nil (lambda (child) (dfs-helper child)) this-node))
             ((consp this-node)
              (map nil (lambda (child) (dfs-helper child)) this-node)))))
      (dfs-helper tree))
    (nreverse sentences)))

(defun read-ancora-es (&rest directories)
  (let ((sentences nil))
    (dolist (directory directories)
      (map-xml-corpus
       (lambda (tree)
         (handler-case
             (dolist (sentence (parse-ancora-tree tree))
               (push sentence sentences))
           (error (c)
             (error "~A: ~A" directory c))))
       directory
       :collect-p nil))
    sentences))

(defun slurp-ancora-corpus (&optional (root-dir "data/ancora-2.0/"))
  (read-ancora-es
   (format nil "~ACESS-CAST-A/" root-dir)
   (format nil "~A3LB-CAST/" root-dir)
   (format nil "~ACESS-CAST-AA/" root-dir)
   (format nil "~ACESS-CAST-P" root-dir)))

(defvar *in-example* nil)
(defun find-word-permutations (tree)
  (cond ((atom tree)
         nil)
        ((and (consp tree)
              (eql (first tree) :|example|))
         (let ((*in-example* t))
           (find-word-permutations (rest tree))))
        ((and (consp tree)
              *in-example*
              (eql (first tree) :|head|))
         (let ((word (remove-if-not 'stringp (rest tree))))
           (list (first word))))
        ((consp tree)
         (nconc (find-word-permutations (first tree))
                (find-word-permutations (rest tree))))))

(defun read-ancora-lexicon (words &rest directories)
  (dolist (directory directories)
    (map-xml-corpus
     (lambda (tree)
       (when (and (eql (first tree) :|lexentry|)
                  (consp (second tree))
                  (every 'consp (rest (second tree)))
                  (member :|lemma| (rest (second tree)) :key 'first))
         (let ((word (second (find :|lemma| (rest (second tree)) :key 'car)))
               (pos (second (find :|type| (rest (second tree)) :key 'car))))
           (cond ((equalp pos "verb")
                  ;; FIXME: conjugate?
                  (setf (gethash word words) +verb-tag+))
                 ((equalp pos "noun")
                  (setf (gethash word words) +noun-tag+)
                  (map nil (lambda (word)
                             (setf (gethash (string-trim '(#\Space) word) words)
                                   +noun-tag+))
                       (delete-duplicates (find-word-permutations tree)
                                          :test 'equal)))
                 (t
                  (error "Unknown type for '~A': '~A'" word pos))))))
     directory
     :collect-p nil))
  words)
