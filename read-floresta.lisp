(in-package :nlp)

(def-pos-map :floresta
    (("\"" ".")
     (")" ".")
     ("(" ".")
     ("-" ".")
     (":" ".")
     (";" ".")
     ("'" ".")
     ("*" ".")
     ("_" ".")
     ("[" ".")
     ("]" ".")
     ("`" ".")
     ("´" ".")
     ("=" ".")
     ("+" ".")
     ("\\" ".")
     (">" ".")
     ("|" ".")
     ("<" ".")
     ("&" ".")
     ("¿" ".")
     ("." ".")
     ("," ".")
     ("N" "NOUN")
     ("PROP" "NOUN")
     ("DET" "DET")
     ("PRP" "ADP")
     ("V" "VERB")
     ("ADV" "ADV")
     ("ADJ" "ADJ")
     ("PERS" "PRON")
     ("NUM" "NUM")
     ("SPEC" "PRON")
     ("KS" "CONJ")
     ("KC" "CONJ")
     ("IN" "PRT")))

(defun convert-ad-pos-to-floresta (pos)
  (case pos
    (:N :N)
    (:PRP :PRP)
    (:PRON-DET :PRON)
    (:V-FIN :V)
    (:|,| :|,|)
    (:ADJ :ADJ)
    (:|.| :|.|)
    (:ADV :ADV)
    (:PROP :PROP)
    (:PRON-INDEF :SPEC)
    (:CONJ-C :KC)
    (:V-INF :V)
    (:PRON-PERS :PERS)
    (:V-PCP :V)
    (:NUM :NUM)
    (:PRON-INDP :PERS)
    (:CONJ-S :KS)
    (:|"| :|"|)
    (:V-GER :V)
    (:|:| :|:|)
    (:|(| :|(|)
    (:SPEC :SPEC)
    (:? :|.|)
    (:|)| :|)|)
    (:PRON-DEM :PERS)
    (:PRON-POSS :PERS)
    (:! :|.|)
    (:|;| :|;|)
    (:VAUX :V)
    (:|'| :|'|)
    (:* :*)
    (:INTJ :IN)
    (:VAUX-S :V)
    (:|_| :|_|)
    (:|]| :|]|)
    (:|[| :|[|)
    (:NP :N)
    (:PRON-INT :PERS)
    (:PRON-REL :PERS)
    (:ADJP :ADJ)
    (:ADVP :ADV)
    (:|`| :|`|)
    (:= :=)
    (:+ :+)
    (:|\|| :|\||)
    (:& :&)
    (:|\\| :|\\|)
    (otherwise nil)))

(defmethod lookup-generic-pos ((name (eql :floresta)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (cdr (assoc pos alist :test 'equalp)))))

(defmethod lookup-specific-pos ((name (eql :floresta)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (let ((tag (car (assoc pos alist :test 'equalp))))
        (when tag
          (intern (string-upcase tag) :keyword))))))

(defun convert-floresta-conll-file (in-file out-file)
  "Convert a Floresta CONLL corpus file into standard word/pos format"
  (with-open-file (stream out-file
                          :element-type 'character
                          :external-format :utf-8
                          :direction :output
                          :if-exists :supersede
                          :if-does-not-exist :create)
    (map-conll-corpus
     (lambda (sentence pos-seq)
       (dotimes (i (length sentence))
         (if (not (lookup-generic-pos :floresta (string-upcase (elt pos-seq i))))
             (log:error "UNKNOWN POS '~A': '~S'" (elt pos-seq i) sentence)
             (progn
               (format stream "~A/~A" (elt sentence i) (elt pos-seq i))
               (if (= i (- (length sentence) 1))
                   (terpri stream)
                   (format stream " "))))))
     in-file)))

(defstruct (floresta-node
             (:conc-name fnode-)
             (:print-function
              (lambda (node stream depth)
                (if (> depth 2)
                    (format stream "#<NODE ~A>" (fnode-value node))
                    (format stream "#<NODE ~A, CHILDREN: ~A>"
                            (fnode-value node) (fnode-children node))))))
  value parent children depth function word pos)

(defun find-ancestor (node depth)
  (let ((new-depth (- (fnode-depth node) depth))
        (ancestor node))
    (dotimes (i new-depth)
      (setq ancestor (fnode-parent ancestor)))
    (fnode-parent ancestor)))

(defun convert-floresta-node-to-cons (root)
  (if (fnode-children root)
      (cons (fnode-pos root)
            (mapcar 'convert-floresta-node-to-cons (fnode-children root)))
      (let ((floresta-pos (convert-ad-pos-to-floresta (fnode-pos root))))
        (if floresta-pos
            (list floresta-pos (fnode-word root))
            (error "Unknown POS '~A'" (fnode-pos root))))))

(defun parse-floresta-line (line)
  ;; SUBJ:n('constituinte' M S) constituintes
  ;; FUNCTION:form('lemma' morphological) word
  (cond ((scan "^[\=]+$" line)
         (values "PUNCT" "=" "="))
        ((equal line "\\")
         (values "PUNCT" "\\" line))
        ((equal line "\\\"")
         (values "PUNCT" "\"" line))
        ((scan "^([·§®¬\\{\\}\\.\\?\\!¡\\:\\;\\(\\)\^\*\>\<]|\\-\\-|\\\\<|\\\\>|\\.\\.\\.|\\$\\$|pause|\\.\\.\\.o|stress|trezentos|Vinte|onora)$" line)
         (values "PUNCT" line line))
        ((scan "^[\=\>\<\-]*(([\\^¬®\\\\«\\{\\}©¿¡\,\"'`´_:;\\+\\(\\)\\[\\]\\?\\.\\!\\|~\\*\\&]|\-\-|\-\-e|\-\-A|\-\-O|\-\-a))$"
               line)
         (values "PUNCT" (regex-replace-all "^[\=\>\<\-]+" line "") line))
        (t (let ((function nil) (form nil) (word nil))
             (register-groups-bind (a b)
                 ("^[\=\>\<\-]*([\\w\\<\\-\"¤\=\\?\\]]+)\:([\\w\-]+)" line)
               (setq function a form b))
             (register-groups-bind (c) ("\\s+([^\\s]+)$" line)
               (setq word c))
             (values function form word)))))

(defun set-fnode-details (node)
  (multiple-value-bind (function form word)
      (parse-floresta-line (fnode-value node))
    (unless (and function)
      (error "Couldn't parse '~A'" (fnode-value node)))
    (setf (fnode-function node) (intern (string-upcase function) :keyword)
          (fnode-pos node) (intern (string-upcase form) :keyword)
          (fnode-word node) word)))

(defun compute-fnode-depth (line)
  (multiple-value-bind (start end) (scan "^([\=]+)" line)
    (if (and start end)
        (if (scan "^[\=]+$" line)
            (- end 1)
            end)
        0)))

(defun parse-floresta-tree (sentence)
  (let ((root (make-floresta-node :value (first sentence) :depth 0)))
    (set-fnode-details root)
    (labels
        ((make-tree (parent lines)
           (when lines
             (handler-case
                 (let* ((line (car lines))
                        (node-depth (compute-fnode-depth line))
                        (node (make-floresta-node :value line
                                                  :depth node-depth)))
                   (set-fnode-details node)
                   (cond ((zerop node-depth)
                          (setf (fnode-children root)
                                (append (fnode-children root)
                                        (list node)))
                          (setf (fnode-parent node) root)
                          (make-tree node (rest lines)))
                         ((= node-depth (fnode-depth parent))
                          (setf (fnode-children (fnode-parent parent))
                                (append (fnode-children (fnode-parent parent))
                                        (list node)))
                          (setf (fnode-parent node) (fnode-parent parent))
                          (make-tree node (rest lines)))
                         ((= node-depth (1+ (fnode-depth parent)))
                          (setf (fnode-children parent)
                                (append (fnode-children parent) (list node)))
                          (setf (fnode-parent node) parent)
                          (make-tree node (rest lines)))
                         ((> node-depth (fnode-depth parent))
                          ;;(error "Went too deep! ~A > ~A" node-depth (fnode-depth parent))
                          (return-from parse-floresta-tree nil)
                          )
                         ((< node-depth (fnode-depth parent))
                          (let ((ancestor (find-ancestor parent node-depth)))
                            (setf (fnode-children ancestor)
                                  (append (fnode-children ancestor)
                                          (list node)))
                            (setf (fnode-parent node) ancestor)
                            (make-tree node (rest lines))))))
               (error (c)
                 (log:error "Problem with line '~A': ~A" (car lines) c)
                 (error "~A" c))))))
      (make-tree root (rest sentence))
      (handler-case
          (list (convert-floresta-node-to-cons root))
        (error (c)
          (log:error "~A" c)
          nil)))))

(defun map-floresta-corpus (fn file &key collect-p
                                      (external-format :latin-1))
  "Apply fn to each entry in a Floresta formatted file."
  (let ((result nil) (sentence nil) (in-sentence-p nil) (id nil))
    (with-open-file (stream file
                            :element-type 'character
                            :external-format external-format)
      (do ((line (read-line stream nil :eof) (read-line stream nil :eof)))
          ((eql line :eof))
        (cond ((scan "^\\<s\\>" line)
               nil)
              ((scan "^SOURCE: " line)
               (setq id line))
              ((scan "^A1$" line)
               (setq in-sentence-p t))
              ((and in-sentence-p
                    (or (zerop (length line))
                        (scan "^\<\/s\>$" line)))
               ;; End of a sentence
               (let ((tree (handler-case
                               (parse-floresta-tree (nreverse sentence))
                             (error (c)
                               (log:error "~A: ~A" id c)
                               nil))))
                 (when tree
                   (if collect-p
                       (push (funcall fn tree) result)
                       (funcall fn tree))
                   (setq in-sentence-p nil sentence nil))))
              (in-sentence-p
               (push line sentence)))))
    (nreverse result)))

(defun convert-floresta-to-sexp (out-file &rest in-files)
  (with-open-file (stream out-file
                          :direction :output
                          :element-type 'character
                          :external-format :latin-1
                          :if-exists :supersede
                          :if-does-not-exist :create)
    (dolist (in-file in-files)
      (map-floresta-corpus
       (lambda (tree)
         (print tree stream)
         (terpri stream))
       in-file))))
