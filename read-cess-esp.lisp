(in-package :nlp)

(def-pos-map :cess
    (("fa" ".")
     ("fc" ".")
     ("fd" ".")
     ("fe" ".")
     ("fg" ".")
     ("fh" ".")
     ("fi" ".")
     ("fp" ".")
     ("fs" ".")
     ("fx" ".")
     ("fz" ".")
     ("number" "NUM")
     ("zm" "NUM")
     ("zp" "NUM")
     ("ao" "ADJ")
     ("aq" "ADJ")
     ("cc" "CONJ")
     ("cs" "CONJ")
     ("da" "DET")
     ("dd" "DET")
     ("de" "DET")
     ("di" "DET")
     ("dn" "DET")
     ("dp" "DET")
     ("dt" "DET")
     ("nc" "NOUN")
     ("np" "NOUN")
     ("p0" "PRON")
     ("pd" "PRON")
     ("pe" "PRON")
     ("pi" "PRON")
     ("pn" "PRON")
     ("pp" "PRON")
     ("pr" "PRON")
     ("pt" "PRON")
     ("px" "PRON")
     ("rg" "ADV")
     ("rn" "ADV")
     ("sn" "ADP")
     ("sp" "ADP")
     ("va" "VERB")
     ("vm" "VERB")
     ("vs" "VERB")
     ("w" "NOUN")
     ("z" "NUM")
     ("x" "X")
     ("y" "X")
     ("i" "X")))

(defmethod lookup-generic-pos ((name (eql :cess)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (cdr (assoc pos alist
                  :test (lambda (key1 key2)
                          (let ((regex (format nil "^~A" key2)))
                            (scan regex key1)))
                  )))))

(defmethod lookup-specific-pos ((name (eql :cess)) pos &key &allow-other-keys)
  (let ((alist (gethash name *pos-maps*)))
    (when alist
      (let ((tag
             (car (assoc pos alist
                         :test (lambda (key1 key2)
                                 (let ((regex (create-scanner
                                               (format nil "^~A" key2)
                                               :case-insensitive-mode t)))
                                   (scan regex key1)))))))
        (when tag
          (intern (string-upcase tag) :keyword))))))

(defun parse-cess-esp-tree (tree)
  (let ((leaf-phrases nil))
    (labels ((dfs-helper (this-node)
               (cond ((and (consp this-node)
                           (atom (first this-node))
                           (atom (second this-node))
                           (atom (third this-node)))
                      (push
                       (cons
                        (string-downcase (format nil "~A" (first this-node)))
                        (string-downcase (format nil "~A" (second this-node))))
                       leaf-phrases))
                     ((and (consp this-node)
                           (atom (first this-node))
                           (consp (second this-node)))
                      (dolist (phrase (rest this-node))
                        (dfs-helper phrase))))))
      (dfs-helper tree))
    (delete-if (lambda (pair)
                 (equal " " (cdr pair)))
               (nreverse leaf-phrases))))

(defun read-cess-esp (directory)
  (let ((sentences nil))
    (dolist (file (cl-fad:list-directory directory))
      (when (cl-ppcre:scan "\.sexp$" (namestring file))
        (handler-case
            (map-sexp-corpus
             (lambda (tree)
               (let ((sentence (parse-cess-esp-tree tree)))
                 (push (mapcar
                        (lambda (pair)
                          (let ((pos (lookup-specific-pos :cess (car pair))))
                            (unless pos
                              (error "UNKNOWN POS IN ~A: ~S" file pair))
                            (cons pos (cdr pair))))
                        sentence)
                       sentences)))
             file
             :collect-p nil
             :external-format :LATIN-1)
          (error (c)
            (log:error "ERROR READING ~A: ~A" file c)))))
    sentences))
